#!/usr/bin/env python
import numpy as np
import roslib
import rospy
import tf
import actionlib
from sparrow_planner.msg import sparrowAction
from geometry_msgs.msg import Polygon
from geometry_msgs.msg import PointStamped
from geometry_msgs.msg import PoseWithCovarianceStamped
from geometry_msgs.msg import PoseStamped
from nav_msgs.msg      import MapMetaData
import path_utils
import utils
from sparrow_planner.msg import grinding_path
from sparrow_planner.srv import GetPathIdx
class SparrowActionServer(object):
    def __init__(self):
        self.server = actionlib.SimpleActionServer('sparrow_action', sparrowAction, self.execute, False)
        self.server.start()
        self.path_pub = rospy.Publisher('/move_base/SparrowPlanner/grinding_path', grinding_path, queue_size=10, latch=True)
        self.parser = path_utils.PathParser()
	rospy.Subscriber('/boundary', Polygon,self.boundaryCb)
	rospy.Subscriber('/amcl_pose', PoseWithCovarianceStamped ,self.poseCb)
	rospy.Subscriber('/clicked_point', PointStamped,self.make_way_point_path)
	rospy.Subscriber('/map_metadata', MapMetaData, self.mapMetaCb)
        self.path_idx_server()
    def mapMetaCb(self, mapMeta):
        self.resolution = mapMeta.resolution
        self.width = mapMeta.width
        self.height = mapMeta.height
        self.o_x = mapMeta.origin.position.x
        self.o_y = mapMeta.origin.position.y
    def poseCb(self, amcl_pose):
        self.pose = amcl_pose
    def make_way_point_path(self, point):
        init_point = np.array([self.pose.pose.pose.position.x,self.pose.pose.pose.position.y])
        self.parser.getPath(init_point, '/home/dysun/map/test.svg', np.array([self.o_x, self.o_y]),self.width, self.height, self.resolution, 0.3)
        path = map(lambda p:self.makePose(p), self.parser.path)
        msg = grinding_path()
        msg.spirial = path
        self.path_pub.publish(msg)

    def makePose(self, point):
        pose = PoseStamped()
        pose.header.stamp = rospy.Time.now()
        pose.header.frame_id = "map"
        pose.pose.position.x = point[0]
        pose.pose.position.y = point[1]
        pose.pose.position.z = 0

        quaternion = tf.transformations.quaternion_from_euler(0, 0, 0)
        pose.pose.orientation.x = quaternion[0]
        pose.pose.orientation.y = quaternion[1]
        pose.pose.orientation.z = quaternion[2]
        pose.pose.orientation.w = quaternion[3]
        return pose

    def execute(self, goal):
    # Do lots of awesome groundbreaking robot stuff here
        self.server.set_succeeded()
    def boundaryCb(self, boundary):
        init_point = [.0,.0]
        points = np.array(map(lambda p: [p.x, p.y], boundary.points))
        print "The boundary is :", points
#        points, self.path_idx = utils.grinding_path2(init_point, points)
        points, self.path_idx = utils.way_points_path()
        path = map(lambda p:self.makePose(p), points)
        msg = grinding_path()
        msg.spirial = path
        self.path_pub.publish(msg)
    def path_idx_server(self):
        print "===================="
    #    rospy.init_node('path_idx_service')
        self.s = rospy.Service('path_idx_service',GetPathIdx, self.publish_path_idx)
    def publish_path_idx(self, req):
	return np.array(self.parser.path_idx)

if __name__ == '__main__':
    rospy.init_node('sparrow_action')
    server = SparrowActionServer()
    rospy.spin()
